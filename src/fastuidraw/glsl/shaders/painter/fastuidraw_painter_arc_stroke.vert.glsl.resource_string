vec4
fastuidraw_gl_vert_main(in uint sub_shader,
                        in uvec4 uprimary_attrib,
                        in uvec4 usecondary_attrib,
                        in uvec4 uint_attrib,
                        in uint shader_data_offset,
                        out int z_add)
{
  vec4 primary_attrib, secondary_attrib;

  primary_attrib = uintBitsToFloat(uprimary_attrib);
  secondary_attrib = uintBitsToFloat(usecondary_attrib);

  uint render_pass;
  bool stroke_width_pixels;
  const float anti_alias_thickness = 1.5;

  #ifndef FASTUIDRAW_STROKE_ONLY_SUPPORT_NON_AA
    {
      render_pass = FASTUIDRAW_EXTRACT_BITS(fastuidraw_stroke_sub_shader_render_pass_bit0,
                                            fastuidraw_stroke_sub_shader_render_pass_num_bits,
                                            sub_shader);
    }
  #else
    {
      render_pass = uint(fastuidraw_stroke_non_aa);
    }
  #endif

  vec2 p;
  vec2 position, center, offset_direction;
  float scale_factor, radius, arc_angle;

  float distance_from_edge_start, distance_from_contour_start;
  float total_edge_length, total_open_contour_length, total_closed_contour_length;

  float stroke_radius;
  int on_boundary, offset_type;
  uint point_packed_data;

  #ifdef FASTUIDRAW_STROKE_DASHED
  fastuidraw_dashed_stroking_params_header stroke_params;
  fastuidraw_read_dashed_stroking_params_header(shader_data_offset, stroke_params);
  #else
  fastuidraw_stroking_params stroke_params;
  fastuidraw_read_stroking_params(shader_data_offset, stroke_params);
  #endif

  position = primary_attrib.xy;
  offset_direction = primary_attrib.zw;
  radius = secondary_attrib.z;
  arc_angle = secondary_attrib.w;
  distance_from_edge_start = secondary_attrib.x;
  distance_from_contour_start = secondary_attrib.y;
  total_edge_length = uintBitsToFloat(uint_attrib.y);
  total_open_contour_length = uintBitsToFloat(uint_attrib.z);
  total_closed_contour_length = uintBitsToFloat(uint_attrib.w);
  point_packed_data = uint_attrib.x;

  offset_type = int(FASTUIDRAW_EXTRACT_BITS(fastuidraw_arc_stroke_offset_type_bit0,
                                            fastuidraw_arc_stroke_offset_type_num_bits,
                                            point_packed_data));
  on_boundary = int(FASTUIDRAW_EXTRACT_BITS(fastuidraw_arc_stroke_boundary_bit,
                                            1,
                                            point_packed_data));

  stroke_width_pixels = (stroke_params.radius < 0.0);
  stroke_radius = abs(stroke_params.radius);
  scale_factor = float(on_boundary) * stroke_radius;

  fastuidraw_arc_stroke_stroke_radius = stroke_radius;
  fastuidraw_arc_stroke_arc_radius = radius;
  center = position - radius * offset_direction;

  if(offset_type == fastuidraw_arc_stroke_arc_point_on_path_origin)
    {
      if (stroke_radius > radius)
        {
          scale_factor = -radius;
        }
      else
        {
          scale_factor = 0.0;
        }
    }

  if (offset_type == fastuidraw_arc_stroke_stroking_boundary_origin)
    {
      if (stroke_radius > radius)
        {
          /* make point at the center and change the behavior to be like
           * an arc-join centered at the same location with stroking
           * radius as stroke_radius - radius
           */
          scale_factor = -radius;
          fastuidraw_arc_stroke_arc_radius = 0.0;
          fastuidraw_arc_stroke_stroke_radius = stroke_radius - radius;
        }
      else
        {
          offset_type = fastuidraw_arc_stroke_stroking_boundary;
        }
    }

  if (offset_type == fastuidraw_arc_stroke_stroking_boundary
      && (point_packed_data & uint(fastuidraw_arc_stroke_inner_stroking_mask)) != 0u)
    {
      if (stroke_radius < radius)
        {
          scale_factor = -scale_factor;
          /* collapse beyond_inner_stroking_boundary to be the same
           * location as inner_stroking_boundary since they are only
           * needed/used when the stroke_radius > radius.
           */
          point_packed_data &= ~uint(fastuidraw_arc_stroke_beyond_boundary_mask);
        }
      else
        {
          position = center;
          scale_factor = stroke_radius - radius;
          offset_direction = -offset_direction;

          /* change the behavior to be like an arc-join centered at the
           * same location with stroknig radius as stroke_radius - radius
           */
          fastuidraw_arc_stroke_arc_radius = 0.0;
          fastuidraw_arc_stroke_stroke_radius = stroke_radius - radius;
        }
    }

  p = position + scale_factor * offset_direction;

  if ((point_packed_data & uint(fastuidraw_arc_stroke_beyond_boundary_mask)) != 0u)
    {
      float half_angle, L, D, c, s;
      vec2 v;

      half_angle = 0.5 * arc_angle;
      if ((point_packed_data & uint(fastuidraw_arc_stroke_end_segment_mask)) != 0u)
        {
          half_angle = -half_angle;
        }

      c = cos(half_angle);
      s = sin(half_angle);
      v.x = c * offset_direction.x - s * offset_direction.y;
      v.y = s * offset_direction.x + c * offset_direction.y;

      L = 1.0 - c;
      D = (fastuidraw_arc_stroke_arc_radius + fastuidraw_arc_stroke_stroke_radius) * L;
      p += D * v;

      /* move p an additional amount so that the edge formed
       * from the beyond boudnary points is atleast one pixel
       * from the stroking-arc boundary.
       */
      vec3 clip_p, clip_direction;
      float d;

      clip_p = fastuidraw_item_matrix * vec3(p, 1.0);
      clip_direction = fastuidraw_item_matrix * vec3(v, 0);
      d = fastuidraw_local_distance_from_pixel_distance(1.0, clip_p, clip_direction);
      p += d / c * v;
    }

  fastuidraw_arc_stroke_relative_to_center_x = p.x - center.x;
  fastuidraw_arc_stroke_relative_to_center_y = p.y - center.y;

  if (offset_type == fastuidraw_arc_stroke_line_segment ||
      offset_type == fastuidraw_arc_stroke_bevel_segment)
    {
      fastuidraw_arc_stroke_arc_radius = -1.0f; //indicate to frag shader to skip arc-coverage
      fastuidraw_arc_stroke_relative_to_center_x = float(on_boundary);
    }

  #if defined(FASTUIDRAW_STROKE_COVER_THEN_DRAW)
    {
      if (render_pass != uint(fastuidraw_stroke_non_aa))
        {
          z_add = 0;
        }
      else
        {
          z_add = int(FASTUIDRAW_EXTRACT_BITS(fastuidraw_arc_stroke_depth_bit0,
                                              fastuidraw_arc_stroke_depth_num_bits,
                                              point_packed_data));
        }
    }
  #else
    {
      z_add = int(FASTUIDRAW_EXTRACT_BITS(fastuidraw_arc_stroke_depth_bit0,
                                          fastuidraw_arc_stroke_depth_num_bits,
                                          point_packed_data));
    }
  #endif

  return vec4(p, p);
}
